#!/usr/bin/env python3
"""
üîê NICEGOLD Enterprise Terminal Lock System
Modern, Beautiful, and Secure Terminal Locking Solution

Version: 1.0 Enterprise Edition
Date: 11 July 2025
Status: Production Ready
"""

import os
import sys
import time
import json
import hashlib
import threading
import datetime
import platform
import getpass
import psutil
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from contextlib import contextmanager

# Rich library for beautiful terminal UI
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
    from rich.text import Text
    from rich.align import Align
    from rich.columns import Columns
    from rich.live import Live
    from rich.layout import Layout
    from rich.box import DOUBLE, ROUNDED, HEAVY
    from rich.prompt import Prompt, Confirm
    from rich.tree import Tree
    from rich.status import Status
    from rich.rule import Rule
    from rich.markdown import Markdown
    from rich import print as rprint
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    print("‚ö†Ô∏è  Rich library not available. Installing...")
    os.system("pip install rich")
    try:
        from rich.console import Console
        from rich.panel import Panel
        from rich.table import Table
        from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
        from rich.text import Text
        from rich.align import Align
        from rich.columns import Columns
        from rich.live import Live
        from rich.layout import Layout
        from rich.box import DOUBLE, ROUNDED, HEAVY
        from rich.prompt import Prompt, Confirm
        from rich.tree import Tree
        from rich.status import Status
        from rich.rule import Rule
        from rich.markdown import Markdown
        from rich import print as rprint
        RICH_AVAILABLE = True
    except ImportError:
        RICH_AVAILABLE = False

# Colorama for cross-platform color support
try:
    from colorama import init, Fore, Back, Style
    init(autoreset=True)
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False


@dataclass
class LockSession:
    """‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Session ‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Ñ"""
    session_id: str
    user: str
    hostname: str
    start_time: datetime.datetime
    end_time: Optional[datetime.datetime] = None
    unlock_attempts: int = 0
    system_info: Dict[str, Any] = None
    security_events: List[Dict[str, Any]] = None
    
    def __post_init__(self):
        if self.security_events is None:
            self.security_events = []
        if self.system_info is None:
            self.system_info = {}


class EnterpriseTerminalLock:
    """
    üîê Enterprise Terminal Lock System
    ‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏ó‡∏≠‡∏£‡πå‡∏°‡∏¥‡∏ô‡∏±‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏á‡∏Ñ‡πå‡∏Å‡∏£‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏ó‡∏≠‡∏£‡πå‡∏°‡∏¥‡∏ô‡∏±‡∏•"""
        self.console = Console(force_terminal=True, width=120) if RICH_AVAILABLE else None
        self.config_path = config_path or "config/terminal_lock_config.json"
        self.lock_file = Path("temp/terminal.lock")
        self.session_file = Path("logs/terminal_lock_sessions.json")
        self.current_session: Optional[LockSession] = None
        self.is_locked = False
        self.lock_thread: Optional[threading.Thread] = None
        self.monitoring_thread: Optional[threading.Thread] = None
        self.stop_monitoring = False
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
        self.lock_file.parent.mkdir(parents=True, exist_ok=True)
        self.session_file.parent.mkdir(parents=True, exist_ok=True)
        
        # ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
        self.config = self._load_config()
        
        # ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏ö‡∏ö
        self.system_info = self._get_system_info()
        
        # ‡∏™‡∏µ‡πÅ‡∏•‡∏∞‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
        self.colors = {
            'primary': '#00D4FF',      # Cyan ‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°
            'secondary': '#FF6B6B',    # Pink ‡∏™‡∏î‡πÉ‡∏™
            'success': '#51CF66',      # Green ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
            'warning': '#FFD93D',      # Yellow ‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            'error': '#FF6B6B',        # Red ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
            'info': '#74C0FC',         # Light blue ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            'dark': '#2C2C2C',         # Dark gray ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
            'light': '#F8F9FA',        # Light gray ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
            'gradient': ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7']
        }
        
        # ASCII Art ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
        self.ascii_art = {
            'lock': '''
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                                    üîê LOCKED üîê                                      ‚ïë
    ‚ïë                                                                                      ‚ïë
    ‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ïë
    ‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïë
    ‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ïë
    ‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù      ‚ïë
    ‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ïë
    ‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïë
    ‚ïë                                                                                      ‚ïë
    ‚ïë                            üè¢ NICEGOLD ENTERPRISE                                   ‚ïë
    ‚ïë                          üîí TERMINAL SECURITY SYSTEM                                ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            ''',
            'unlock': '''
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                                   üîì UNLOCKED üîì                                     ‚ïë
    ‚ïë                                                                                      ‚ïë
    ‚ïë  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó                ‚ïë
    ‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó               ‚ïë
    ‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë               ‚ïë
    ‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë               ‚ïë
    ‚ïë  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù               ‚ïë
    ‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù                ‚ïë
    ‚ïë                                                                                      ‚ïë
    ‚ïë                           ‚úÖ ACCESS GRANTED                                          ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            '''
        }
    
    def _load_config(self) -> Dict[str, Any]:
        """‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö"""
        default_config = {
            "security": {
                "max_unlock_attempts": 3,
                "auto_lock_timeout": 300,  # 5 ‡∏ô‡∏≤‡∏ó‡∏µ
                "require_password": True,
                "password_hash": None,
                "session_timeout": 3600,  # 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
                "enable_monitoring": True,
                "log_attempts": True
            },
            "display": {
                "theme": "enterprise",
                "animation_speed": 0.05,
                "show_system_info": True,
                "show_real_time_stats": True,
                "refresh_interval": 1.0,
                "enable_gradient": True
            },
            "features": {
                "auto_screenshot": False,
                "remote_monitoring": False,
                "email_alerts": False,
                "webhook_notifications": False
            }
        }
        
        try:
            if Path(self.config_path).exists():
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                # Merge with default config
                self._merge_config(default_config, config)
                return default_config
            else:
                # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå config ‡πÉ‡∏´‡∏°‡πà
                Path(self.config_path).parent.mkdir(parents=True, exist_ok=True)
                with open(self.config_path, 'w', encoding='utf-8') as f:
                    json.dump(default_config, f, indent=2, ensure_ascii=False)
                return default_config
        except Exception as e:
            print(f"‚ö†Ô∏è  Error loading config: {e}")
            return default_config
    
    def _merge_config(self, base: Dict, update: Dict) -> None:
        """‡∏ú‡∏™‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤"""
        for key, value in update.items():
            if key in base:
                if isinstance(base[key], dict) and isinstance(value, dict):
                    self._merge_config(base[key], value)
                else:
                    base[key] = value
            else:
                base[key] = value
    
    def _get_system_info(self) -> Dict[str, Any]:
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏ö‡∏ö"""
        try:
            memory = psutil.virtual_memory()
            cpu_percent = psutil.cpu_percent(interval=1)
            disk_usage = psutil.disk_usage('/')
            
            return {
                'hostname': platform.node(),
                'platform': platform.platform(),
                'python_version': platform.python_version(),
                'cpu_count': psutil.cpu_count(),
                'cpu_percent': cpu_percent,
                'memory_total': memory.total,
                'memory_available': memory.available,
                'memory_percent': memory.percent,
                'disk_total': disk_usage.total,
                'disk_used': disk_usage.used,
                'disk_free': disk_usage.free,
                'disk_percent': (disk_usage.used / disk_usage.total) * 100,
                'uptime': time.time() - psutil.boot_time(),
                'timestamp': datetime.datetime.now().isoformat()
            }
        except Exception as e:
            return {
                'hostname': platform.node(),
                'platform': platform.platform(),
                'error': str(e),
                'timestamp': datetime.datetime.now().isoformat()
            }
    
    def _generate_session_id(self) -> str:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á Session ID ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô"""
        timestamp = datetime.datetime.now().isoformat()
        hostname = platform.node()
        user = getpass.getuser()
        combined = f"{timestamp}_{hostname}_{user}"
        return hashlib.md5(combined.encode()).hexdigest()[:12]
    
    def _hash_password(self, password: str) -> str:
        """‡πÅ‡∏Æ‡∏ä‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô"""
        return hashlib.sha256(password.encode()).hexdigest()
    
    def _verify_password(self, password: str) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô"""
        if not self.config['security']['password_hash']:
            return True  # ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏ß‡πâ
        
        hashed = self._hash_password(password)
        return hashed == self.config['security']['password_hash']
    
    def set_password(self, password: str) -> None:
        """‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô"""
        self.config['security']['password_hash'] = self._hash_password(password)
        self._save_config()
    
    def _save_config(self) -> None:
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤"""
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"‚ö†Ô∏è  Error saving config: {e}")
    
    def _save_session(self) -> None:
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Session"""
        if not self.current_session:
            return
        
        try:
            sessions = []
            if self.session_file.exists():
                with open(self.session_file, 'r', encoding='utf-8') as f:
                    sessions = json.load(f)
            
            # ‡πÅ‡∏õ‡∏•‡∏á datetime ‡πÄ‡∏õ‡πá‡∏ô string
            session_data = asdict(self.current_session)
            session_data['start_time'] = self.current_session.start_time.isoformat()
            if self.current_session.end_time:
                session_data['end_time'] = self.current_session.end_time.isoformat()
            
            sessions.append(session_data)
            
            with open(self.session_file, 'w', encoding='utf-8') as f:
                json.dump(sessions, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"‚ö†Ô∏è  Error saving session: {e}")
    
    def _show_welcome_screen(self) -> None:
        """‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö"""
        if not RICH_AVAILABLE:
            print("üîê NICEGOLD Enterprise Terminal Lock System")
            print("=" * 60)
            return
        
        # Clear screen
        self.console.clear()
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á Layout ‡∏´‡∏•‡∏±‡∏Å
        layout = Layout()
        
        # Header
        header = Panel(
            Align.center(
                Text("üîê NICEGOLD Enterprise Terminal Lock System", 
                     style="bold bright_cyan"),
                vertical="middle"
            ),
            box=DOUBLE,
            style="bright_cyan",
            height=5
        )
        
        # System Info
        system_table = Table(show_header=True, header_style="bold bright_white")
        system_table.add_column("Property", style="bright_cyan")
        system_table.add_column("Value", style="bright_white")
        
        system_table.add_row("Hostname", self.system_info.get('hostname', 'Unknown'))
        system_table.add_row("Platform", self.system_info.get('platform', 'Unknown'))
        system_table.add_row("User", getpass.getuser())
        system_table.add_row("Session ID", self.current_session.session_id if self.current_session else 'None')
        system_table.add_row("Timestamp", datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        
        system_panel = Panel(
            system_table,
            title="üñ•Ô∏è  System Information",
            box=ROUNDED,
            style="bright_blue"
        )
        
        # Status
        status_text = Text("üîì UNLOCKED", style="bold bright_green")
        if self.is_locked:
            status_text = Text("üîê LOCKED", style="bold bright_red")
        
        status_panel = Panel(
            Align.center(status_text),
            title="Status",
            box=ROUNDED,
            style="bright_yellow"
        )
        
        # Layout setup
        layout.split_column(
            Layout(header, name="header", size=5),
            Layout(name="main", ratio=2),
            Layout(status_panel, name="status", size=5)
        )
        
        layout["main"].split_row(
            Layout(system_panel, name="system"),
            Layout(name="stats")
        )
        
        # Stats
        if self.config['display']['show_real_time_stats']:
            stats_table = Table(show_header=True, header_style="bold bright_white")
            stats_table.add_column("Metric", style="bright_cyan")
            stats_table.add_column("Value", style="bright_white")
            
            # CPU ‡πÅ‡∏•‡∏∞ Memory
            memory = psutil.virtual_memory()
            cpu_percent = psutil.cpu_percent()
            
            stats_table.add_row("CPU Usage", f"{cpu_percent:.1f}%")
            stats_table.add_row("Memory Usage", f"{memory.percent:.1f}%")
            stats_table.add_row("Available Memory", f"{memory.available / (1024**3):.1f} GB")
            stats_table.add_row("CPU Cores", str(psutil.cpu_count()))
            
            stats_panel = Panel(
                stats_table,
                title="üìä Real-time Statistics",
                box=ROUNDED,
                style="bright_magenta"
            )
            
            layout["stats"].update(stats_panel)
        
        # Display
        with Live(layout, refresh_per_second=2, console=self.console) as live:
            time.sleep(3)
    
    def _show_lock_screen(self) -> None:
        """‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏•‡πá‡∏≠‡∏Ñ"""
        if not RICH_AVAILABLE:
            print(self.ascii_art['lock'])
            return
        
        self.console.clear()
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á animated lock screen
        lock_panel = Panel(
            Align.center(
                Text(self.ascii_art['lock'], style="bold bright_red"),
                vertical="middle"
            ),
            title="üîê TERMINAL LOCKED",
            box=HEAVY,
            style="bright_red"
        )
        
        # ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Ñ
        lock_info = Table(show_header=True, header_style="bold bright_white")
        lock_info.add_column("Information", style="bright_yellow")
        lock_info.add_column("Value", style="bright_white")
        
        if self.current_session:
            lock_info.add_row("Session ID", self.current_session.session_id)
            lock_info.add_row("User", self.current_session.user)
            lock_info.add_row("Hostname", self.current_session.hostname)
            lock_info.add_row("Lock Time", self.current_session.start_time.strftime("%Y-%m-%d %H:%M:%S"))
            lock_info.add_row("Duration", str(datetime.datetime.now() - self.current_session.start_time))
            lock_info.add_row("Unlock Attempts", str(self.current_session.unlock_attempts))
        
        info_panel = Panel(
            lock_info,
            title="üìã Lock Information",
            box=ROUNDED,
            style="bright_blue"
        )
        
        # Real-time monitoring
        monitoring_panel = self._create_monitoring_panel()
        
        # Layout
        layout = Layout()
        layout.split_column(
            Layout(lock_panel, name="lock", size=15),
            Layout(name="main", ratio=2)
        )
        
        layout["main"].split_row(
            Layout(info_panel, name="info"),
            Layout(monitoring_panel, name="monitoring")
        )
        
        self.console.print(layout)
    
    def _create_monitoring_panel(self) -> Panel:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö"""
        if not RICH_AVAILABLE:
            return Panel("Monitoring not available")
        
        monitoring_table = Table(show_header=True, header_style="bold bright_white")
        monitoring_table.add_column("System Metric", style="bright_cyan")
        monitoring_table.add_column("Current Value", style="bright_white")
        monitoring_table.add_column("Status", style="bright_green")
        
        # ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        try:
            memory = psutil.virtual_memory()
            cpu_percent = psutil.cpu_percent()
            processes = len(psutil.pids())
            
            monitoring_table.add_row("CPU Usage", f"{cpu_percent:.1f}%", "üü¢ Normal" if cpu_percent < 80 else "üî¥ High")
            monitoring_table.add_row("Memory Usage", f"{memory.percent:.1f}%", "üü¢ Normal" if memory.percent < 80 else "üî¥ High")
            monitoring_table.add_row("Active Processes", str(processes), "üü¢ Normal")
            monitoring_table.add_row("System Uptime", f"{psutil.boot_time():.0f}s", "üü¢ Active")
            
        except Exception as e:
            monitoring_table.add_row("Error", str(e), "üî¥ Error")
        
        return Panel(
            monitoring_table,
            title="üìä System Monitoring",
            box=ROUNDED,
            style="bright_magenta"
        )
    
    def _animate_lock(self) -> None:
        """‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Ñ"""
        if not RICH_AVAILABLE:
            print("üîê Locking...")
            return
        
        with self.console.status("[bold bright_yellow]Locking terminal...", spinner="dots") as status:
            for i in range(3):
                time.sleep(0.5)
                status.update(f"[bold bright_yellow]Locking{'.' * (i + 1)}")
            
            status.update("[bold bright_red]üîê LOCKED!")
            time.sleep(1)
    
    def _animate_unlock(self) -> None:
        """‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ"""
        if not RICH_AVAILABLE:
            print("üîì Unlocking...")
            return
        
        with self.console.status("[bold bright_green]Unlocking terminal...", spinner="dots") as status:
            for i in range(3):
                time.sleep(0.5)
                status.update(f"[bold bright_green]Unlocking{'.' * (i + 1)}")
            
            status.update("[bold bright_green]üîì UNLOCKED!")
            time.sleep(1)
    
    def _monitoring_loop(self) -> None:
        """‡∏ß‡∏ô‡∏£‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö"""
        while not self.stop_monitoring and self.is_locked:
            try:
                # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏ö‡∏ö
                self.system_info = self._get_system_info()
                
                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
                if self.current_session:
                    monitoring_data = {
                        'timestamp': datetime.datetime.now().isoformat(),
                        'system_info': self.system_info,
                        'session_id': self.current_session.session_id
                    }
                    self.current_session.security_events.append(monitoring_data)
                
                # ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
                time.sleep(self.config['display']['refresh_interval'])
                
            except Exception as e:
                print(f"‚ö†Ô∏è  Monitoring error: {e}")
                time.sleep(5)
    
    def lock(self) -> None:
        """‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏ó‡∏≠‡∏£‡πå‡∏°‡∏¥‡∏ô‡∏±‡∏•"""
        if self.is_locked:
            print("‚ö†Ô∏è  Terminal is already locked!")
            return
        
        # ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö
        self._show_welcome_screen()
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á Session ‡πÉ‡∏´‡∏°‡πà
        self.current_session = LockSession(
            session_id=self._generate_session_id(),
            user=getpass.getuser(),
            hostname=platform.node(),
            start_time=datetime.datetime.now(),
            system_info=self.system_info
        )
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏•‡πá‡∏≠‡∏Ñ
        self.lock_file.touch()
        with open(self.lock_file, 'w', encoding='utf-8') as f:
            json.dump(asdict(self.current_session), f, default=str, indent=2)
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
        self.is_locked = True
        
        # ‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Ñ
        self._animate_lock()
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö
        if self.config['security']['enable_monitoring']:
            self.stop_monitoring = False
            self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
            self.monitoring_thread.start()
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Session
        self._save_session()
        
        print("üîê Terminal locked successfully!")
        if RICH_AVAILABLE:
            self.console.print("üîê [bold bright_red]Terminal locked successfully![/bold bright_red]")
    
    def unlock(self, password: Optional[str] = None) -> bool:
        """‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏ó‡∏≠‡∏£‡πå‡∏°‡∏¥‡∏ô‡∏±‡∏•"""
        if not self.is_locked:
            print("‚ö†Ô∏è  Terminal is not locked!")
            return True
        
        # ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏•‡πá‡∏≠‡∏Ñ
        self._show_lock_screen()
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô
        if self.config['security']['require_password']:
            if not password:
                if RICH_AVAILABLE:
                    password = Prompt.ask("üîë Enter password to unlock", password=True)
                else:
                    password = getpass.getpass("üîë Enter password to unlock: ")
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ
            if self.current_session:
                self.current_session.unlock_attempts += 1
            
            if not self._verify_password(password):
                if RICH_AVAILABLE:
                    self.console.print("‚ùå [bold bright_red]Invalid password![/bold bright_red]")
                else:
                    print("‚ùå Invalid password!")
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°
                if (self.current_session and 
                    self.current_session.unlock_attempts >= self.config['security']['max_unlock_attempts']):
                    
                    if RICH_AVAILABLE:
                        self.console.print("üö® [bold bright_red]Maximum unlock attempts reached![/bold bright_red]")
                    else:
                        print("üö® Maximum unlock attempts reached!")
                    
                    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
                    if self.current_session:
                        security_event = {
                            'timestamp': datetime.datetime.now().isoformat(),
                            'event': 'max_unlock_attempts_reached',
                            'attempts': self.current_session.unlock_attempts
                        }
                        self.current_session.security_events.append(security_event)
                    
                    return False
                
                return False
        
        # ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        self.is_locked = False
        self.stop_monitoring = True
        
        # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Session
        if self.current_session:
            self.current_session.end_time = datetime.datetime.now()
        
        # ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏•‡πá‡∏≠‡∏Ñ
        if self.lock_file.exists():
            self.lock_file.unlink()
        
        # ‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ
        self._animate_unlock()
        
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Session
        self._save_session()
        
        # ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ
        if RICH_AVAILABLE:
            unlock_panel = Panel(
                Align.center(
                    Text(self.ascii_art['unlock'], style="bold bright_green"),
                    vertical="middle"
                ),
                title="üîì TERMINAL UNLOCKED",
                box=HEAVY,
                style="bright_green"
            )
            self.console.print(unlock_panel)
        else:
            print(self.ascii_art['unlock'])
        
        print("üîì Terminal unlocked successfully!")
        return True
    
    def status(self) -> Dict[str, Any]:
        """‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Ñ"""
        return {
            'is_locked': self.is_locked,
            'current_session': asdict(self.current_session) if self.current_session else None,
            'lock_file_exists': self.lock_file.exists(),
            'system_info': self.system_info,
            'config': self.config
        }
    
    def show_sessions(self) -> None:
        """‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ Session"""
        if not self.session_file.exists():
            print("üìã No sessions found.")
            return
        
        try:
            with open(self.session_file, 'r', encoding='utf-8') as f:
                sessions = json.load(f)
            
            if not RICH_AVAILABLE:
                print("üìã Terminal Lock Sessions:")
                print("-" * 50)
                for session in sessions[-10:]:  # ‡πÅ‡∏™‡∏î‡∏á 10 session ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                    print(f"Session ID: {session['session_id']}")
                    print(f"User: {session['user']}")
                    print(f"Start: {session['start_time']}")
                    print(f"End: {session.get('end_time', 'Not ended')}")
                    print(f"Attempts: {session['unlock_attempts']}")
                    print("-" * 50)
                return
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏ß‡∏¢ Rich
            sessions_table = Table(show_header=True, header_style="bold bright_white")
            sessions_table.add_column("Session ID", style="bright_cyan")
            sessions_table.add_column("User", style="bright_white")
            sessions_table.add_column("Hostname", style="bright_blue")
            sessions_table.add_column("Start Time", style="bright_green")
            sessions_table.add_column("End Time", style="bright_yellow")
            sessions_table.add_column("Duration", style="bright_magenta")
            sessions_table.add_column("Attempts", style="bright_red")
            
            for session in sessions[-10:]:  # ‡πÅ‡∏™‡∏î‡∏á 10 session ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                start_time = datetime.datetime.fromisoformat(session['start_time'])
                end_time = session.get('end_time')
                
                if end_time:
                    end_time = datetime.datetime.fromisoformat(end_time)
                    duration = str(end_time - start_time)
                    end_time_str = end_time.strftime("%H:%M:%S")
                else:
                    duration = "Ongoing"
                    end_time_str = "N/A"
                
                sessions_table.add_row(
                    session['session_id'][:8],
                    session['user'],
                    session['hostname'],
                    start_time.strftime("%H:%M:%S"),
                    end_time_str,
                    duration,
                    str(session['unlock_attempts'])
                )
            
            sessions_panel = Panel(
                sessions_table,
                title="üìã Terminal Lock Sessions (Last 10)",
                box=ROUNDED,
                style="bright_blue"
            )
            
            self.console.print(sessions_panel)
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error loading sessions: {e}")
    
    def cleanup(self) -> None:
        """‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏£‡∏∞‡∏ö‡∏ö"""
        # ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        self.stop_monitoring = True
        
        # ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏ñ‡πâ‡∏≤‡∏•‡πá‡∏≠‡∏Ñ‡∏≠‡∏¢‡∏π‡πà
        if self.is_locked:
            self.is_locked = False
            if self.current_session:
                self.current_session.end_time = datetime.datetime.now()
                self._save_session()
        
        # ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏•‡πá‡∏≠‡∏Ñ
        if self.lock_file.exists():
            self.lock_file.unlink()
        
        print("üßπ Terminal lock system cleaned up.")
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.cleanup()


def main():
    """‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö"""
    print("üîê NICEGOLD Enterprise Terminal Lock System")
    print("=" * 60)
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ
    with EnterpriseTerminalLock() as lock_system:
        while True:
            print("\nüìã Available Commands:")
            print("1. üîê Lock Terminal")
            print("2. üîì Unlock Terminal")
            print("3. üìä Show Status")
            print("4. üìã Show Sessions")
            print("5. üîë Set Password")
            print("6. üö™ Exit")
            
            try:
                choice = input("\nüéØ Enter your choice: ").strip()
                
                if choice == "1":
                    lock_system.lock()
                elif choice == "2":
                    lock_system.unlock()
                elif choice == "3":
                    status = lock_system.status()
                    print("\nüìä System Status:")
                    print(f"Locked: {status['is_locked']}")
                    print(f"Lock File: {status['lock_file_exists']}")
                    if status['current_session']:
                        print(f"Session ID: {status['current_session']['session_id']}")
                elif choice == "4":
                    lock_system.show_sessions()
                elif choice == "5":
                    password = getpass.getpass("üîë Enter new password: ")
                    confirm = getpass.getpass("üîÑ Confirm password: ")
                    if password == confirm:
                        lock_system.set_password(password)
                        print("‚úÖ Password set successfully!")
                    else:
                        print("‚ùå Passwords do not match!")
                elif choice == "6":
                    break
                else:
                    print("‚ùå Invalid choice!")
                    
            except KeyboardInterrupt:
                print("\n\nüõë Interrupted by user")
                break
            except Exception as e:
                print(f"\n‚ö†Ô∏è  Error: {e}")
    
    print("\nüëã Goodbye!")


if __name__ == "__main__":
    main() 